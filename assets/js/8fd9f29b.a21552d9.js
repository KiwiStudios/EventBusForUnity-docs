"use strict";(self.webpackChunkeventbusforunity=self.webpackChunkeventbusforunity||[]).push([[285],{8700:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"getting-started/listeners-with-dependencies","title":"Listeners with dependencies","description":"A stumble block you might encounter due to the unordered nature of how listeners are registered is that you would want ListenerA to run before ListenerB. And ListenerC to run after ListenerB.","source":"@site/docs/getting-started/listeners-with-dependencies.md","sourceDirName":"getting-started","slug":"/getting-started/listeners-with-dependencies","permalink":"/EventBusForUnity-docs/getting-started/listeners-with-dependencies","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"documentationSidebar","previous":{"title":"Async usage","permalink":"/EventBusForUnity-docs/getting-started/async-usage"},"next":{"title":"API Documentation","permalink":"/EventBusForUnity-docs/category/api-documentation"}}');var r=t(4848),i=t(8453);const o={sidebar_position:7},a="Listeners with dependencies",d={},c=[];function l(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"listeners-with-dependencies",children:"Listeners with dependencies"})}),"\n",(0,r.jsx)(n.p,{children:"A stumble block you might encounter due to the unordered nature of how listeners are registered is that you would want ListenerA to run before ListenerB. And ListenerC to run after ListenerB."}),"\n",(0,r.jsx)(n.p,{children:"You can achieve this by using the following syntax when defining your listeners:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public class MyClass : MonoBehaviour\n{\n    // can be fully namespaced name\n    [Listener(runBefore: new[] { nameof(MyClass.ListenerB) })]\n    private void ListenerA(OnHelloWorldEvent message)\n    {\n        Debug.Log("Hello from ListenerA");\n    }\n    \n    // or just the local reference to the method\n    [Listener(runAfter: new[] { nameof(ListenerB) })]\n    private void ListenerC(OnHelloWorldEvent message)\n    {\n        Debug.Log("Hello from ListenerC");\n    }\n    \n    [Listener]\n    private void ListenerB(OnHelloWorldEvent message)\n    {\n        Debug.Log("Hello from ListenerB");\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["See the parameter usage of ",(0,r.jsx)(n.code,{children:"[Listener]"})," for more details."]}),"\n",(0,r.jsxs)(n.p,{children:["Note: You should always pass an array of ",(0,r.jsx)(n.code,{children:"nameof()"})," references when defining dependencies like the above snippet."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);